# Mongoose Guide

## 1. Connecting to DB

1. After importing mongoose, you can connect to a DB using `.connect()`.
   `.connect()` accepts three params:

   - the connection URL (local or remote)
   - a callback run on connection success
   - a callback that handles DB errors

```js
// main.js

mongoose.connect("mongodb://localhost/crashCourse", () => {
  console.log("Connected to crashCourse DB!"),
    (err) => {
      console.error(err);
    };
});
```

## 2. Defining a basic schema

- Create `/schema/Idol.js`

Note that the example's types are Capitalized; they are the constructors for that type.

```js
// /schema/Idol.js

const idolSchema = new mongoose.Schema({
  name: String,
  height: Number,
});
```

## 3. Creating and exporting the model

Create the model by calling `mongoose.model` and passing it two parameters:

- a Capitalized string, serves as the name for the `Model`
- the variable containing the schema

Ultimately, we want to use this newly created model throughout this project so we need to export it. The exports line should

```js
// /schema/Idol.js

module.exports = mongoose.model("Idol", idolSchema);
```

## 4. Importing the `Idol` model

We can import `idolSchema` for use in our `main` file the same way we can import any other JS export.

```js
// main.js

const Idol = require("./schema/Idol");
```

## 5. Creating a `new` Idol document instance

With Idol imported, we can create a new instance of the Idol model, and store its reference in a variable.

```js
// main.js

const idol1 = new Idol({ name: "Ina", height: 157 });
```

## 6. Saving the new document to the DB

This only creates the instance, but DOES NOT save it to the DB. For that, we need to `.save()` it to the DB. `.save()` is an async function, so it's `.then()`-able, but in most operations, you'll be running this and other async DB methods inside a general async function.

### Using `.then()`

```js
idol1.save().then(() => console.log("idol1 saved"));
```

### Using `async/await` (best practice)

```js
async function run() {
  const idol2 = new Idol({ name: "Mori Calliope", height: 167 });
  await idol2.save();
  console.log(idol2);
}
run();
```

## 7. Examining the DB's save record

Now that the idol instance has been created and saved, we can see the `console.log` output:

```json
{
  name: 'Mori Calliope',
  height: 167,
  _id: new ObjectId("61df270f6e92202ab49a08f0"),
  __v: 0
}
```

The name and height fields are there as defined in the `idolSchema`, and MongoDB has also added 2 additional auto-generated fields to the document:

- `_id`: a unique identifier generated by MongoDB
- `__v`: Mongo's internal document version tracker

## 8. Refactoring `run()` to use a model's `.create()` function

`.create()` is an async function available to Models that combines the `new` instance process and async `.save()` method into one method. This means that we can consolidate multiple lines of code into a cleaner syntax.

### Before: using the `new` keyword and manual `.save()`

```js
async function run() {
  const idol2 = new Idol({ name: "Mori Calliope", height: 167 });
  await idol2.save();
}
```

### After: using `Model.create()`

```js
async function run() {
  const idol2 = await Idol.create({ name: "Mori Calliope", height: 167 });
}
```

## 9. Manually updating fields on a created document

After the `.create()` method is run, you can choose to edit a document's fields directly and then call `.save()` after.

```js
// main.js

async function run() {
  const idol2 = await Idol.create({ name: "Mori Calliope", height: 167 });

  // The new entry is created and stored within the `idol2` variable.
  // In this example, we're gonna change the details of the newly created document
  idol2.name = "Ina";
  idol2.height = 157;

  // Once the changes are made, you call `.save()` to complete the update.
  idol2.save();

  console.log(idol2);
}
```

## 10. Exploring schema types/expanding `Idol` schema

Let's add to the `Idol` schema.

```js
// Idol.js

const idolSchema = new mongoose.Schema({
  name: String,
  height: Number,
  debut: Date,
  fanName: String,
  unit: String,
  unitMembers: [mongoose.SchemaTypes.ObjectId],
  hashtags: {
    streamTags: [String],
    fanArt: [String],
  },
  createdAt: Date,
  updatedAt: Date,
});
```

We can create an array of items by simply wrapping the `Type` in array brackets.

`mongoose.SchemaTypes.ObjectId]` tells MongoDB that this field is a reference to another `ObjectId`; another Idol object. We'll come back to this value later on in the `.populate()` section.

We can also nest fields inside a document since documents are JSON-based; same rules apply here.

On save, you'll see the console update with these details to the `Mori Calliope` document; it'll feature the new fields defined in the schema.

```json
{
  name: 'Calliope',
  height: 167,
  unitMembers: [],
  hashtags: { streamTags: [], fanArt: [] },
  _id: new ObjectId("61df30f54ef4e08fbbb7fe97"),
  __v: 0
}
```

## 11. Updating the `Idol` entry

We can update select fields from the `run()` function to reflect the changes made to the `Idol` schema.

```js
// main.js

async function run() {
  const idol2 = await Idol.create({
    name: "Mori Calliope",
    height: 167,
    subCount: 1880000,
    unit: "hololive English -Myth-",
    hashtags: {
      streamTags: ["#calliolive"],
      fanArt: ["#callillust"],
    },
  });
  console.log(idol2);
}
```

## 12. Redefining `hashtags` as a sub-schema

Depending on the complexity of nested document fields, it might be best to create a sub-schema and reference it within the parent schema.

Note that each sub-schema does introduce its own `ObjectId` to the the parent schema, so its the sub-schema is simple, you can keep it nested _without_ creating a new schema.

### Before

```js
const idolSchema = new mongoose.Schema({
  name: String,
  height: Number,
  debut: Date,
  subCount: Number,
  fanName: String,
  unit: String,
  unitMembers: [mongoose.SchemaTypes.ObjectId],
  hashtags: {
    streamTags: [String],
    fanArt: [String],
  },
  createdAt: Date,
  updatedAt: Date,
});
```

### After

```js
const hashtagSchema = new mongoose.Schema({
  streamTags: [String],
  fanArt: [String],
});

const idolSchema = new mongoose.Schema({
  name: String,
  height: Number,
  debut: Date,
  subCount: Number,
  fanName: String,
  unit: String,
  unitMembers: [mongoose.SchemaTypes.ObjectId],
  hashtags: hashtagSchema, // <-- notice the new schema ref
  createdAt: Date,
  updatedAt: Date,
});
```

### Save output

```json
{
  name: 'Mori Calliope',
  height: 167,
  subCount: 1880000,
  unit: 'hololive English -Myth-',
  unitMembers: [],
  hashtags: {
    streamTags: [ '#calliolive' ],
    fanArt: [ '#callillust' ],
    _id: new ObjectId("61df3cbcbe8ee57556ff5223")
  },
  _id: new ObjectId("61df3cbcbe8ee57556ff5222"),
  __v: 0
}
```

## 13. Document field errors

By defining the types in the schema, you can catch errors when a document's field type doesn't match the defined schema. Wrap the `.create()` operation in a `try/catch` block.

### Type error

```js
// Idol.js: Idol Schema
// subCount is expected to be a number
subCount: Number,
```

```js
// main.js

async function run() {
  const idol2 = await Idol.create({
    name: "Mori Calliope",
    height: 167,
    subCount: "lots of fans", // <- the type error
    unit: "hololive English -Myth-",
    hashtags: {
      streamTags: ["#calliolive"],
      fanArt: ["#callillust"],
    },
  });
  console.log(idol2);
}
```

This produces the following type error.

```shell
UnhandledPromiseRejectionWarning: ValidationError: Idol validation failed: subCount: Cast to Number failed for value "lots of fans" (type string) at path "subCount"
```

### Wrapped in `try/catch`

```js
// main.js

async function run() {
  try {
    const idol2 = await Idol.create({
      name: "Mori Calliope",
      height: 167,
      subCount: "lots of fans", // <- the type error

      unit: "hololive English -Myth-",
      hashtags: {
        streamTags: ["#calliolive"],
        fanArt: ["#callillust"],
      },
    });
    console.log(idol2);
  } catch (err) {
    console.error(err.message);
  }
}
```

This produces the console error message: `Idol validation failed: subCount: Cast to Number failed for value "lots of fans" (type string) at path "subCount"`

## 14. Required document fields

To require a field, we have to modify the schema types from just their basic definition, to an object, containing a `type` key-value pair, and a `required: true` key-value pair.

### Making `fanName` required

```js
// schema/Idol.js

const idolSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  height: Number,
  debut: Date,
  subCount: Number,
  fanName: {
    type: String,
    required: true,
  },
  unit: String,
  unitMembers: [mongoose.SchemaTypes.ObjectId],
  hashtags: hashtagSchema,
  createdAt: Date,
  updatedAt: Date,
});
```

### Required Errors

When we save, there is an error produced: `Idol validation failed: fanName: Path 'fanName' is required.`. This can be fixed by assigning a value to that required document field.

```js
// main.js

async function run() {
  try {
    const idol2 = await Idol.create({
      name: "Mori Calliope",
      height: 167,
      subCount: 1880000,
      fanName: "Dead Beats",
      unit: "hololive English -Myth-",
      hashtags: {
        streamTags: ["#calliolive"],
        fanArt: ["#callillust"],
      },
    });
    console.log(idol2);
  } catch (err) {
    console.error(err.message);
  }
}
```

```json
// resulting success DB console log
{
  name: 'Mori Calliope',
  height: 167,
  subCount: 1880000,
  fanName: 'Dead Beats',
  unit: 'hololive English -Myth-',
  unitMembers: [],
  hashtags: {
    streamTags: [ '#calliolive' ],
    fanArt: [ '#callillust' ],
    _id: new ObjectId("61df446192142667b12c8df7")
  },
  _id: new ObjectId("61df446192142667b12c8df6"),
  __v: 0
}
```

## 15. Document field attribute validation

### Transformations

In addition to requiring fields, you can also transform fields based on their type. Given a string, you can dictate whether it's `lowercase` or `uppercase`.

```js
const someSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    lowercase: true, // emails are case insensitive
  },
});
```

### Defaults

You can dictate default values if a field is not assigned a value in a similar way.

```js
{
  createdAt: {
    type: Date,
    default: () => Date.now(), // runs if this value is not assigned at creation time
  },
}
```

### Immutability

Defining `immutable` as `true` will ensure that once the value exists, it can never be changed; a useful attribute for things like document creation dates.

Manual updates to immutable fields are ignored.

```js
{
  createdAt: {
    type: Date,
    immutable: true, // once this value is set, it's permanent
    default: () => Date.now(),
  },
}
```

### Minimums/Maximums

#### Numbers

```js
{
  subCount: {
    type: Number,
    min: 0,
    max: 10 000 000 000
  },
}
```

#### Strings

```js
{
  name: {
    type: String,
    minLength: 1
  },
}
```

### Custom validation

Custom validators are objects that contain a `validator` key-function pair, and a `message` key-string pair.

```js
// Silly custom even subcount check
{
  {
  subCount: {
    type: Number,
    min: 0,
    max: 10 000 000 000
    validate: {
      validator: val => val % 2 === 0,
      message: props => `${props.value} is not an even sub count.`
    }
  },
}
}
```

### Updated `Idol` schema

```js
const hashtagSchema = new mongoose.Schema({
  streamTags: [String],
  fanArt: [String],
});

const idolSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  height: Number,
  debut: Date,
  subCount: Number,
  fanName: {
    type: String,
    required: true,
  },
  unit: String,
  unitMembers: [mongoose.SchemaTypes.ObjectId],
  hashtags: hashtagSchema,
  createdAt: {
    type: Date,
    immutable: true,
    default: () => Date.now(),
  },
  updatedAt: {
    type: Date,
    default: () => Date.now(),
  },
});
```

## 16. MongoDB methods that skip validation; a warning

Using the built-in validation is nice, but only the `.create()` and `.save()` methods validate this way.

There are lots of Model methods like `.findOneAndReplace()`, or `.updateMany()` that do not use this validation because they work directly on the DB.

Instead, do singular operations and then run `.save()` on them; the official `mongoose` documentation recommends this as best practice:

> `.findOneAndX` and `.findByIdAndX` functions support _limited validation_ that you can enable by setting the `runValidators` option.
>
> If you need full-fledged validation, use the traditional approach of first retrieving the document.
>
> ```js
> // BAD
> await User.findByIdAndReplace(); // supports limited validation; not the full suite
>
> // Good: grab the doc(s), update as needed, then manually `.save()`, triggering the validation
> const doc = await User.findById(id);
> doc.name = "jason bourne";
> await doc.save();
> ```

## 17. Querying documents

### Single document queries

#### By specific `ObjectId`

`Model.findById("<ObjectID goes here>")`. Returns a single document object if ID is found. Returns `null` if no match is found.

```js
// main.js

try {
  const idol = await Idol.findById("61df446192142667b12c8df6");
  console.log(user);
} catch (err) {
  console.error(err);
}

// user logged:
{
  _id: new ObjectId("61df446192142667b12c8df6"),
  name: 'Mori Calliope',
  height: 167,
  subCount: 1880000,
  fanName: 'Dead Beats',
  unit: 'hololive English -Myth-',
  unitMembers: [],
  hashtags: {
    streamTags: [ '#calliolive' ],
    fanArt: [ '#callillust' ],
    _id: new ObjectId("61df446192142667b12c8df7")
  },
  createdAt: 2022-01-12T21:13:05.915Z,
  updatedAt: 2022-01-12T21:13:05.915Z,
  __v: 0
}
```

#### Any single match

`Model.findOne({ field: searchValue })`. Returns first matching document. Returns `null` if no match found.

```js
// main.js

try {
  const idol = await Idol.findOne({ name: "Mori Calliope" });
  console.log(user);
} catch (err) {
  console.error(err.message);
}

// returns first match (notice how it DOESN'T have the now required fanName field):
{
  _id: new ObjectId("61df3154a36885799975e5c2"),
  name: 'Mori Calliope',
  height: 167,
  unitMembers: [],
  hashtags: {
    _id: new ObjectId("61df5511c734cb13ceb01826"),
    streamTags: [],
    fanArt: []
  },
  __v: 0,
  updatedAt: 2022-01-12T22:24:17.329Z
}
```

#### Whether or not any matching document exists

`Model.exists({ field: searchValue })`. Returns `true` if a document that matches criteria is found. Returns `false` when there's no match.

```js
// main.js

try {
  const idol = await Idol.exists({ name: "Mori" });
  console.log(user);
} catch (err) {
  console.error(err.message);
}

// returns
true;
```

#### Deleting first match

`Model.deleteOne({ field: searchValue })`. When logged, returns a `{ deletedCount:1 }` object if a match was found. Returns `{deletedCount: 0}` when no document match was found

### Multiple document queries

`Model.find({ key: searchValue })`. Returns array of all matching documents based on input fields. Returns an empty array when there are no matches.

```js
// main.js

try {
  const idols = await Idol.find({ name: "Mori Calliope" });
  console.log(idols);
} catch (err) {
  console.error(err.message);
}

// returns:
[array of 16 matching docs]
```

## 18. `.where()` queries

`.where()` queries in Mongoose allow for chainable query methods.

### Base syntax

`Model.where("field").queryMethod(searchValue)`

### Using specific `.findOne()` method

```js
const idol = await Idol.findOne({ name: "Mori Calliope" });
```

### Equivalent `.where()` query

```js
const idol = await Idol.where("name").equals("Mori Calliope");
```

### Chaining `.where()` queries

Let's say we want to find an `Idol` document where the name is `Mori Calliope` and the subcount is `1880000`.

```js
// main.js
const idol = await Idol.where("name")
  .equals("Mori Calliope")
  .where("subCount")
  .equals(1880000);
```

### Select chainable `.where()` methods

These methods just chained version of standard mongodb selectors. Some important ones to know are:

- `.lt(Number)`: less than
- `.gt(Number)`: greater than
- `.lte(Number)`: less than or equal to
- `.gte(Number)`: greater than or equal to
- `.limit(Number)`: Specifies the maximum number of documents the query will return
- `.skip(Number)`: Specifies the number of documents to skip
- `.sort(value)`: Specifies the number of documents to skip

  - valid sort values are `'asc'`, `'desc'`, `'ascending'`, `'descending'`, `1`, and `-1`

    ```js
    // sort by "field" ascending and "test" descending
    query.sort({ field: "asc", test: -1 });

    // equivalent
    query.sort("field -test");
    ```

#### Multiple Number chains

Find an `Idol` where the age is greater than 19, but less than or equal to 100.

```js
const idols = await Idol.where("age").gt(19).lte(1000);
```

## 19. References and adding `unitMembers`

Modify the `Idol` model's `unitMembers` to tell Mongoose that the `ObjectId` referenced is an instance of the `Idol` model. The `ref` option is what tells Mongoose which model to use during population. Let's expand `Idol` into a validation object.

```js
// Idol.js

{
  //... earlier fields omitted
  unitMembers: {
    type: [mongoose.SchemaTypes.ObjectId],
    ref: "Idol"
  },
  ...
}
```

### Adding a `unitMember`

#### Ina

```js
// main.js

try {
  const idol = await Idol.create({
    name: "Ninomae Ina'nis",
    height: 157,
    fanName: "tentacult",
  });
  console.log(idol);
} catch (err) {
  console.error(err.message);
}

// returns Idol ObjectId
 _id: new ObjectId("61df5c65ec7063a3c645f99e"),
```

#### Nene

Add the member to get the `ObjectId`.

```js
// main.js

try {
  const idol = await Idol.create({
    name: "Momosuzu Nene",
    height: 159,
    fanName: "Husbands (or Wives)",
  });
  console.log(idol);
} catch (err) {
  console.error(err.message);
}

// returns a successful Nene Idol document
 _id: new ObjectId("61df5b73207eb636829b828b"),
```

### Associating the members to each other

Limit the results to one `Idol` document. If necessary, update document with missing required fields if returned result was created **BEFORE** validation section.

### Value Assignment

**NB: Even with `.limit()` in place, results are returned in an array; array will be empty if no matches found.**

#### Single value reference

In the case of a single value reference, you can directly assign that value with `=`, as described in an earlier section that first detailed manual updates and saves.

```js
// Remember that we're dealing with the first value of the results array.

// if illustrator was a field...
idol[0].illustrator = "61df5c65ec7063a3c645f99e";
await idol[0].save();
```

#### Adding to an array of references

We can push the `ObjectId` value to the references array.

```js
// Remember that we're dealing with the first value of the results array.

// if illustrator was a field...
idol[0].unitMembers.push("61df5c65ec7063a3c645f99e");
await idol[0].save();
```

The result will be reflected as an `ObjectId` and **not** a plain string thanks to the `ref` field added to `Idol.unitMembers` object.

```json
// result; notice the version update and addition to `unitMembers`
[
  {
    _id: new ObjectId("61df3154a36885799975e5c2"),
    name: 'Mori Calliope',
    height: 167,
    unitMembers: [ new ObjectId("61df5c65ec7063a3c645f99e") ],
    hashtags: {
      _id: new ObjectId("61df5fbbf5c95319b2f61ef0"),
      streamTags: [],
      fanArt: []
    },
    __v: 3,
    fanName: 'Dead Beats',
    updatedAt: 2022-01-12T23:00:15.023Z
  }
]
```

## 20. `.populate()`

`.populate()` is a method that allows you to do what is an essentially a join operation to grab data based off a reference and add it to the current selected entry(ies).

`.populate()` **DOES NOT** modify the populated entry(ies); it automatically replaces the specified paths in the document with document(s) from other collection(s).

We may populate a single document, multiple documents, a plain object, multiple plain objects, or all objects returned from a query.

### Preparing the schema for population

When you have a field that you can populate on, you need to ensure that that field, also contains a `ref` key referring to the Model name to use the `ObjectId` to search on.

```js
// Idol.js

// Before
unitMembers: [mongoose.SchemaTypes.ObjectId]

// After
unitMembers: { type: [mongoose.SchemaTypes.ObjectId], ref: "Idol" }
```

### Adding Ina's data to Calliope's `bestFriend` array.

Ina's `ObjectId` ref already exists in that array, so we can populate Ina's data there.

```js
try {
  const idol = await Idol.where("name")
    .equals("Mori Calliope")
    .populate("unitMembers") // the field where the refs are
    .limit(1);
  console.log(idol[0]);
} catch (err) {
  console.error(err.message);
}
```

Notice how Ina's data is now present in this Calliope entry, instead of simply containing the `ObjectId` ref.

```json
// console.log(idol[0]) output;

{
  _id: new ObjectId("61df3154a36885799975e5c2"),
  name: 'Mori Calliope',
  height: 167,
  unitMembers: [
    {
      _id: new ObjectId("61df5c65ec7063a3c645f99e"),
      name: "Ninomae Ina'nis",
      height: 157,
      fanName: 'tentacult',
      unitMembers: [],
      createdAt: 2022-01-12T22:55:33.893Z,
      updatedAt: 2022-01-12T22:55:33.893Z,
      __v: 0
    }
  ],
  hashtags: {
    _id: new ObjectId("61df62ace61bcc3b0d811d1d"),
    streamTags: [],
    fanArt: []
  },
  __v: 3,
  fanName: 'Dead Beats',
  updatedAt: 2022-01-12T23:00:15.023Z
}
```

## 21. Adding schema methods

Since schema are the basis for document object creation, we can add methods to them the same way that we could for classes. Schema methods use `this` the way that Class methods do to reference attributes on the instance of the model created.

```js
// Idol.js

// After the idolSchema definition, before the export!
idolSchema.methods.sayHi = function () {
  console.log(`Hello, my name is ${this.name}!`);
};
```

Now we can invoke the `sayHi` method on every `Idol` instance.

```js
// crashCourse.js

try {
  const idol = await Idol.findOne({ name: "Mori Calliope" });
  idol.sayHi();
} catch (err) {
  console.error(err.message);
}

// outputs
// Hello, my name is Mori Calliope!
```

## 22. Adding schema static methods

We can also add static methods to the `Model` itself, the same that we could add functions to a Class and not its instances.

```js
// Idol.js

/**
 * Here we use `.find()` because we don't want to chain off a query,
 * we just want to return matching data based only off these parameters.
 * @function findByName
 * @param {String} name
 * @returns {Object[]}
 */
idolSchema.statics.findByName = function (name) {
  return this.find({ name: new RegExp(name, "i") });
};
```

We can then call that static function in our `run()` function.

```js
// crash-course.js

try {
  const idols = await Idol.findByName("Mori Calliope");
  console.log(idols.length);
} catch (err) {
  console.error(err.message);
}

// outputs
[
  // ...array of 16 Idol document objects
];
```

## 23. Adding methods to queries (make them chainable!)

We can add methods that only operate on queries you run to the schema. For this query method, we'll be chaining mongoose's `.where()` with this `.byName()` function.

```js
// Idol.js

/**
 * The `.where()` query is formatted as if it were as a `.find()` query;
 * it accepts a details key-value pairs object .
 * We chain off a blank `.find()`, as it returns a mongoose query object.
 *
 * @function findByName
 * @param {String} name
 * @returns {Object[]}
 */
idolSchema.query.byName = function (name) {
  return this.where({ name: new RegExp(name, "i") });
};
```

```js
// main.js:
// using .find()

try {
  const idols = await Idol.find().byName("Mori");
  console.log(idols);
} catch (err) {
  console.error(err.message);
}

// OR using .where(), since it also returns a Query object

try {
  const idols = await Idol.where().byName("Mori");
  console.log(idols);
} catch (err) {
  console.error(err.message);
}
```

## 24. Adding virtual methods

We can query for data and then use a virtual method to combine queried fields.

Virtual methods are named and use getters and setters, just like Classes can, and therefore are **NOT** invoked. The virtual itself is not a function, but rather its getter/setter function is; this means that

### What purpose do virtual methods serve?

**TL;DR: if you can compose new, commonly used data from existing document fields, use a virtual method, instead of adding a field to the document.**

Let's say that we create a virtual method `namedSubCount`, that will grab a single `Idol` document's `name` and `subCount` fields, format, and return them in a string of our choosing.

If this is an operation that needs to be done often, it's less data for the DB to store if we can form this new data from **already existing** data on a document(s). Here, the `namedSubCount` function allows for us to not have to create a `namedSubCount` field on each `Idol` document.

```js
// Idol.js

idolSchema.virtual("namedSubCount").get(function () {
  return `Hi, I'm ${this.name}, and I currently have ${this.subCount} subs on YouTube!`;
});
```

```js
// main.js

/**
 * First query for data
 * Once data, a single Idol document, is fetched,
 * we can call virtual method on that Idol doc
 */

try {
  const idol = await Idol.findOne({ subCount: 1880000 });
  console.log(idol.namedSubCount);
} catch (err) {
  console.error(err.message);
}

// output:
// Hi, I'm Mori Calliope, and I currently have 1880000 subs on YouTube!
```

## 25. Schema Middleware [(docs)](https://mongoosejs.com/docs/middleware.html)

Schema middleware (also known as _pre-hooks_ and _post-hooks_) works very similarly to `Express` middleware; it allows you to insert and run code in between actions.

There is middleware that covers **saving, validating, removing, and updating one**.

### `.pre()` & `.post()`

As their method name implies, `.pre()` and `.post()` and middleware that run _before_ or _after_ a particular Mongo action occurs.

#### Function signature

Remember that since Mongo documents are essentially instances of a `Model` class, we use `this` to refer to the current instance.

```js
schemaName.method("<action>", callbackFN(document,next) {
  // `document` is optional; next can be only field passed in

  // using this!
  this.someDocField = someStuffEtc

  next() // call it to end this middleware and continue down middleware chain
});

/**
 * "<action>": dependent on desired action level; document, model, query, aggregate
 * see docs for all options
 */
```

### Using middleware to update a field

#### `.pre()`

Before every save, we want to update the `updatedAt` field to reflect the time of this latest document `save` action.

```js
// Idol.js

idolSchema.pre("save", function (next) {
  this.updatedAt = Date.now();
  next();
});
```

#### `.post()`

Same idea, but we're gonna use the document we just updated as a parameter

```js
// Idol.js

idolSchema.post("save", function (doc, next) {
  doc.sayHi();
  next();
});
```

### Verifying the order of middleware

From our `.pre()` method, remove the `next()` invocation. Notice how the operation hangs if `next` isn't called, exactly how it'd hang in a typical Express middleware function.

```js
// Idol.js

// For the save action, order is pre-save, save, post-save.

idolSchema.pre("save", function (next) {
  this.updatedAt = Date.now();
  throw new Error("Failed save"); // no next() call!
});

idolSchema.post("save", function (doc, next) {
  doc.sayHi();
  next();
});
```

The `.post()` save middleware will never run because because there is no `next()` call in the `.pre()` middleware to allow mongoose to move on! Replacing that `throw new Error` call with a `next()` invocation fixes this problem.
